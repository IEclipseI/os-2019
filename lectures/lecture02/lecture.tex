\documentclass[../lectures.tex]{subfiles}

\begin{document}

\chapter{Процессы}

Процесс - эксзкмпляр запущенной программы. Процессы должны уметь договариваться
чтобы сосуществовать, но в то же времся не знать друг о друге и владеть
монополией на ресурс машины. С точки зрения ОС процесс - это абстракция,
позволяющая абстрагироваться от внутренностей процеса. С точки зрения
программиста процесс = абстракция, которая позволяет думать что мы монопольно
владеем ресурсами машины.

На момент выполнения процесс можно охарактеризовать полным состоянием его памяти
и регистров. Чтобы приостановить процесс нам нужно просто сохранить его
'отпечаток', а чтобы возобновить нужно загрузить его память и регистры.
одноядерках.

Батч-процессы типа сборки, компиляции не требуют отзывчивости пока жрут ресурсы.

\section{Немного повторения}

\begin{itemize}
    \item \emph{fork()} - для того чтобы создать новый процесс
    \item \emph{wait(pid)} - ждем процесс
    \item \emph{exit()} - завершаемся
    \item \emph{SIGKILL} - принудительное завершение другого процесса (\shell{kill})
\end{itemize}

\section{PID}

\begin{itemize}
    \item У каждого \emph{PID} есть parentPID (\emph{PPID})

    \item \shell{ps} - позволяет посмотреть специфичные атрибуты процесса

    \item Процесс \emph{init(pid 0)} создается ядром и выступает родителем для большинства процессов, созданных в системе

    \item Можно построить дерево процессов (\shell{pstree})
\end{itemize}

Процесс делает \emph{fork()}. Возможны 2 случая:
\begin{enumerate}
    \item 
        Процесс не делает \emph{wait(childpid)}

        Зомби-процесс (\emph{zombie}) - когда дочерний процесс завершается быстрее, чем вы сделаете wait
    \item 
        Процесс завершается, что происходит с дочерним процессом?

        Сирота (\emph{orphan}) - процесс, у которого умер родитель. Ему назначется родителем процесс с \emph{pid 1}, который время от времени делает \emph{wait()} и освобождается от детей
\end{enumerate}
\emph{PID} - переиспользуемая вещь (таблица процессов)

\section{Calling convention}
\shell{man syscall} - как вызываются \emph{syscall}

\code{syscall.h}{C}
\code{syscall.s}{asm}
\code{main.c}{C}

Что здесь просходит?
\begin{enumerate}
    \item Вызываем write()
    \item Просим ядро записать 555 байт начинающихся по адресу 0 в файловый дескриптор №1 (\emph{stdout} - №1, \emph{stdin} - №2, \emph{stderr} - №3)
    \item 
        Ничего не происходит, так как:

        \emph{write(1, NULL, 555)} возвращает -1 (\emph{EFAULT} - Bad address)
\end{enumerate}

Как со всем этим работать?
\begin{itemize}
    \item \shell{strace} - трассировка процесса (подсматриваем за процессом, последовательность \emph{syscall} с аргументами и кодами возврата)

    Если \emph{syscall} ничего не возвращает, то в выводе пишется ? вместо возвращаемого значения

    \item \shell{man errno} - ошибки

    Если делаем \emph{fork()} - проверяем код возврата (хорошая практика)

    \emph{char* strerror(int errnum)} - возвращает строковое описание кода ошибки

    Почему \emph{char*}, а не \emph{const char*}? Потому что всем было лень.

    \emph{thread\_local} - решение проблемы: переменная с ошибкой - общая для каждого потока

    \item До \emph{main()} и прочего (конструкторы) происходит куча всего (\emph{munmap, mprotect, mmap, access}) - размещение процесса в памяти и т.д.

    \item Программа не всегда завершается по языковым гарантиям (деструкторы)

    \item \shell{ptrace} - позволяет одному процессу следить за другим (используется, например, в \emph{GDB})
\end{itemize}

\section{Диаграмма времени жизни процесса и взаимодействия с ОС}
\image{state-diagram.png}

\section{Homework} 
Написать shell-интерпретатор
\begin{itemize}
    \item Читать из stdin 
    \item В дочернем процессе execve()
    \item В родительском процессе wait()
    \item Сдавать через гитхаб
\end{itemize}

\section{Переключение контекста}
Шедулер ОС раскидывает процессы и создает иллюзию одновременного выполнения на
Здесь иллюстрируется иллюзия многозадачности
\image{context-switch.png}

\end{document}
