\documentclass[../lectures.tex]{subfiles}

\begin{document}

\chapter{Процессы}

\todo{from day02}

\section{Немного повторения}
fork() - для того чтобы заместить процесс?
wait(pid) - ждем процесс
exit() - завершаемся
SIGKILL - принудительное завершение другого процесса (\emph{kill})

У каждого pid есть parentpid (ppid)
\emph{ps} - позволяет посмотреть специфичные атрибуты процесса
Процесс init(pid 0) создается ядром, выступает родителем для большинства процессов, созданных в системе
Тогда можно построить дерево процессов (\emph{pstree})

Процесс делает fork(). 2 случая:
1. Процесс не делает wait(childpid)
Зомби-процесс - когда дочерний процесс завершается быстрее чем вы сделаете wait
2. Процесс завершается, что происходит с дочерним процессом?
Сирота(orphan) - процесс у которого умер родитель, ему назначется родителем процесс с pid 1(время от времени делает wait() и освобождается от детей)
pid - переиспользуемая штука (таблица процессов)

\section{Calling convention}
Как вызываются syscall (\emph{man syscall})
\begin{lstlisting}
syscall.h
#ifndef SYSCALL_H
#define SYSCALL_H

void IFMO_syscall();

#endif

main.c
#include "syscall.h"

int main(...) {
    IFMO_syscal();
}

syscall.s
.data

.text
.global IFMO_syscall

IFMO_syscall:
    movq $1, %rax
    movq $1, %rdi
    movq $0, %rsi
    movq $555, %rdx
    syscall
    ret
\end{lstlisting}

Вызываем write()
Просим ядро записать 555 байт начинающихся по адресу 0 в файловый дескриптор №1
№1 stdout
№2 stdin
№3 stderr
Ничего не происходит?
Утилита \emph{strace} - трассировка процесса (подсматриваем за процессом, последовательность syscall с аргументами и кодами возврата)
write(1, NULL, 555) возвращает -1 EFAULT (Bad address)
Если syscall ничего не возвращает, то пишется "?" вместо возвращаемого значения
\emph{man errno} - ошибки
Если делаем fork() - проверяем код возврата
char* strerror(int errnum) - возвращает строковое описание кода ошибки
Почему char*, а не const char*? Потому что всем было лень.

$thread_local$ - решение проблемы: переменная с ошибкой - общая для каждого потока?

До main() и прочего (конструкторы) происходит куча всего (munmap, mprotect, mmap, access) - размещение процесса в памяти и т.д.
Программа не всегда завершается по языковым гарантиям (деструкторы)

\emph{ptrace} - позволяет одному процессу следить за другим (используется, например, в gdb)

\section{Диаграмма времени жизни процесса и взаимодействия с ОС}
.png

\section{Дз1} 
Написать shell-интерпретатор
Читать из stdin 
В дочернем процессе execve()
В родительском процессе wait()
Сдавать через гитхаб

\section{Переключение контекста(иллюзия многозадачности)}
.png

\end{document}
