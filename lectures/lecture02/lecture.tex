\documentclass[../lectures.tex]{subfiles}

\begin{document}

\chapter{Процессы}

\todo{from day02}

\section{Немного повторения}

\begin{itemize}
    \item fork() - для того чтобы заместить процесс?
    \item wait(pid) - ждем процесс
    \item exit() - завершаемся
    \item SIGKILL - принудительное завершение другого процесса (\emph{kill})
\end{itemize}

\section{PID}

\begin{itemize}
    \item У каждого pid есть parentpid (ppid)

    \item \emph{ps} - позволяет посмотреть специфичные атрибуты процесса

    \item Процесс init(pid 0) создается ядром, выступает родителем для большинства процессов, созданных в системе

    \item Тогда можно построить дерево процессов (\emph{pstree})
\end{itemize}

Процесс делает fork(). Возможны 2 случая:
\begin{enumerate}
    \item 
        Процесс не делает wait(childpid)

        Зомби-процесс - когда дочерний процесс завершается быстрее чем вы сделаете wait
    \item 
        Процесс завершается, что происходит с дочерним процессом?

        Сирота (orphan) - процесс у которого умер родитель. Ему назначется родителем процесс с pid 1, который время от времени делает wait() и освобождается от детей
\end{enumerate}
pid - переиспользуемая штука (таблица процессов)

\section{Calling convention}
\lstinputlisting[language=C]{src/syscall.h}
\lstinputlisting[language={[x86masm]Assembler}]{src/syscall.s}
\lstinputlisting[language=C]{src/main.c}

Как вызываются syscall (\emph{man syscall})
\begin{enumerate}
    \item Вызываем write()
    \item Просим ядро записать 555 байт начинающихся по адресу 0 в файловый дескриптор №1
    \item №1 stdout
    \item №2 stdin
    \item №3 stderr
    \item Ничего не происходит?
\end{enumerate}

Утилита \emph{strace} - трассировка процесса (подсматриваем за процессом, последовательность syscall с аргументами и кодами возврата)

write(1, NULL, 555) возвращает -1 EFAULT (Bad address)

Если syscall ничего не возвращает, то пишется $?$ вместо возвращаемого значения

\emph{man errno} - ошибки

Если делаем fork() - проверяем код возврата (хорошая практика)

char* strerror(int errnum) - возвращает строковое описание кода ошибки

Почему char*, а не const char*? Потому что всем было лень.

thread local - решение проблемы: переменная с ошибкой - общая для каждого потока?

До main() и прочего (конструкторы) происходит куча всего (munmap, mprotect, mmap, access) - размещение процесса в памяти и т.д.
Программа не всегда завершается по языковым гарантиям (деструкторы)

\emph{ptrace} - позволяет одному процессу следить за другим (используется, например, в gdb)

\section{Диаграмма времени жизни процесса и взаимодействия с ОС}
.png

\section{Дз1} 
\begin{itemize}
    \item Написать shell-интерпретатор
    \item Читать из stdin 
    \item В дочернем процессе execve()
    \item В родительском процессе wait()
    \item Сдавать через гитхаб
\end{itemize}

\section{Переключение контекста (иллюзия многозадачности)}
.png

\end{document}
